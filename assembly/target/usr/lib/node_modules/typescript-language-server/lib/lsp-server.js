"use strict";
/*
 * Copyright (C) 2017, 2018 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lsp = require("vscode-languageserver");
const fs = require("fs");
const commandExists = require("command-exists");
const logger_1 = require("./logger");
const tsp_client_1 = require("./tsp-client");
const diagnostic_queue_1 = require("./diagnostic-queue");
const modules_resolver_1 = require("./modules-resolver");
const protocol_translation_1 = require("./protocol-translation");
const protocol_translation_2 = require("./protocol-translation");
const utils_1 = require("./utils");
const document_1 = require("./document");
exports.WORKSPACE_EDIT_COMMAND = "workspace-edit";
class LspServer {
    constructor(options) {
        this.options = options;
        this.openedDocumentUris = new Map();
        this.logger = new logger_1.PrefixingLogger(options.logger, '[lspserver]');
        this.diagnosticQueue = new diagnostic_queue_1.DiagnosticEventQueue(diagnostics => this.options.lspClient.publishDiagnostics(diagnostics), this.logger);
    }
    closeAll() {
        for (const [uri, doc] of this.openedDocumentUris) {
            this.didCloseTextDocument({
                textDocument: {
                    uri,
                    languageId: 'typescript',
                    version: doc.version,
                    text: doc.text
                }
            });
        }
    }
    findTsserverPath() {
        if (this.options.tsserverPath) {
            return this.options.tsserverPath;
        }
        // 1) look into node_modules of workspace root
        let executable = modules_resolver_1.findPathToModule(this.rootPath(), `.bin/${utils_1.getTsserverExecutable()}`);
        if (executable) {
            return executable;
        }
        // 2) use globally installed tsserver
        if (commandExists.sync(utils_1.getTsserverExecutable())) {
            return utils_1.getTsserverExecutable();
        }
        // 3) look into node_modules of typescript-language-server
        const bundled = modules_resolver_1.findPathToModule(__dirname, `.bin/${utils_1.getTsserverExecutable()}`);
        if (!bundled) {
            throw Error(`Couldn't find '${utils_1.getTsserverExecutable()}' executable`);
        }
        return bundled;
    }
    initialize(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log('initialize', params);
            this.initializeParams = params;
            const tsserverPath = this.findTsserverPath();
            this.tspClient = new tsp_client_1.TspClient({
                tsserverPath,
                logFile: this.options.tsserverLogFile,
                logVerbosity: this.options.tsserverLogVerbosity,
                logger: this.options.logger,
                onEvent: this.onTsEvent.bind(this)
            });
            this.tspClient.start();
            this.initializeResult = {
                capabilities: {
                    textDocumentSync: lsp.TextDocumentSyncKind.Incremental,
                    completionProvider: {
                        triggerCharacters: ['.'],
                        resolveProvider: true
                    },
                    codeActionProvider: true,
                    definitionProvider: true,
                    documentFormattingProvider: true,
                    documentHighlightProvider: true,
                    documentSymbolProvider: true,
                    executeCommandProvider: {
                        commands: [exports.WORKSPACE_EDIT_COMMAND]
                    },
                    hoverProvider: true,
                    renameProvider: true,
                    referencesProvider: true,
                    signatureHelpProvider: {
                        triggerCharacters: ['(', ',']
                    },
                    workspaceSymbolProvider: true,
                }
            };
            this.logger.log('onInitialize result', this.initializeResult);
            return this.initializeResult;
        });
    }
    requestDiagnostics() {
        const files = [];
        // sort by least recently usage
        const orderedUris = [...this.openedDocumentUris.entries()].sort((a, b) => a[1].lastAccessed - b[1].lastAccessed).map(e => e[0]);
        for (const uri of orderedUris) {
            files.push(protocol_translation_2.uriToPath(uri));
        }
        const args = {
            delay: 0,
            files: files
        };
        return this.tspClient.request("geterr" /* Geterr */, args);
    }
    didOpenTextDocument(params) {
        const path = protocol_translation_2.uriToPath(params.textDocument.uri);
        this.logger.log('onDidOpenTextDocument', params, path);
        if (this.openedDocumentUris.get(params.textDocument.uri) !== undefined) {
            this.logger.log(`Cannot open already opened doc '${params.textDocument.uri}'.`);
            this.didChangeTextDocument({
                textDocument: params.textDocument,
                contentChanges: [
                    {
                        text: params.textDocument.text
                    }
                ]
            });
        }
        else {
            this.tspClient.notify("open" /* Open */, {
                file: path,
                fileContent: params.textDocument.text
            });
            this.openedDocumentUris.set(params.textDocument.uri, new document_1.LspDocument(params.textDocument));
            this.requestDiagnostics();
        }
    }
    didCloseTextDocument(params) {
        const path = protocol_translation_2.uriToPath(params.textDocument.uri);
        this.logger.log('onDidCloseTextDocument', params, path);
        this.tspClient.notify("close" /* Close */, { file: path });
        this.openedDocumentUris.delete(params.textDocument.uri);
        // We won't be updating diagnostics anymore for that file, so clear them
        // so we don't leave stale ones.
        this.options.lspClient.publishDiagnostics({
            uri: params.textDocument.uri,
            diagnostics: [],
        });
    }
    didChangeTextDocument(params) {
        const path = protocol_translation_2.uriToPath(params.textDocument.uri);
        this.logger.log('onDidCloseTextDocument', params, path);
        const document = this.openedDocumentUris.get(params.textDocument.uri);
        if (!document) {
            this.logger.error("Received change on non-opened document " + params.textDocument.uri);
            throw new Error("Received change on non-opened document " + params.textDocument.uri);
        }
        document.markAccessed();
        for (const change of params.contentChanges) {
            let line, offset, endLine, endOffset = 0;
            if (!change.range) {
                line = 1;
                offset = 1;
                const endPos = document.getPosition(document.text.length);
                endLine = endPos.line + 1;
                endOffset = endPos.character + 1;
            }
            else {
                line = change.range.start.line + 1;
                offset = change.range.start.character + 1;
                endLine = change.range.end.line + 1;
                endOffset = change.range.end.character + 1;
            }
            this.tspClient.notify("change" /* Change */, {
                file: path,
                line,
                offset,
                endLine,
                endOffset,
                insertString: change.text
            });
        }
        this.requestDiagnostics();
    }
    didSaveTextDocument(params) {
        // do nothing
    }
    definition(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('definition', params, path);
            const result = yield this.tspClient.request("definition" /* Definition */, {
                file: path,
                line: params.position.line + 1,
                offset: params.position.character + 1
            });
            return result.body ? result.body
                .map(fileSpan => protocol_translation_2.toLocation(fileSpan)) : [];
        });
    }
    documentSymbol(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('symbol', params, path);
            const response = yield this.tspClient.request("navtree" /* NavTree */, {
                file: path
            });
            if (!response.body) {
                return [];
            }
            const result = [];
            const collectSymbol = (element, parent, acceptor) => {
                const start = element.spans[0];
                const end = element.spans[element.spans.length - 1];
                if (start && end) {
                    const symbol = lsp.SymbolInformation.create(element.text, protocol_translation_2.toSymbolKind(element.kind), { start: protocol_translation_2.toPosition(start.start), end: protocol_translation_2.toPosition(end.end) }, params.textDocument.uri, parent);
                    acceptor(symbol);
                }
                if (element.childItems) {
                    for (const child of element.childItems) {
                        collectSymbol(child, element.text, acceptor);
                    }
                }
            };
            collectSymbol(response.body, undefined, sym => result.push(sym));
            return result;
        });
    }
    completion(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('completion', params, path);
            const result = yield this.tspClient.request("completions" /* Completions */, {
                file: path,
                line: params.position.line + 1,
                offset: params.position.character + 1,
                prefix: '',
                includeExternalModuleExports: true,
                includeInsertTextCompletions: true
            });
            return {
                isIncomplete: false,
                items: result.body ? result.body
                    .map(item => {
                    return {
                        label: item.name,
                        kind: protocol_translation_2.completionKindsMapping[item.kind],
                        // store information for resolve
                        data: {
                            file: path,
                            line: params.position.line + 1,
                            offset: params.position.character + 1
                        }
                    };
                }) : []
            };
        });
    }
    completionResolve(item) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log('completion/resolve', item);
            const result = yield this.tspClient.request("completionEntryDetails" /* CompletionDetails */, {
                entryNames: [item.label],
                file: item.data.file,
                line: item.data.line,
                offset: item.data.offset,
            });
            if (!result.body) {
                return item;
            }
            if (result.body[0] && result.body[0].documentation) {
                item.documentation = result.body[0].documentation.map(i => i.text).join('\n');
            }
            return item;
        });
    }
    hover(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('hover', params, path);
            let result;
            try {
                result = yield this.tspClient.request("quickinfo" /* Quickinfo */, {
                    file: path,
                    line: params.position.line + 1,
                    offset: params.position.character + 1
                });
            }
            catch (err) {
                return {
                    contents: []
                };
            }
            if (!result.body) {
                return {
                    contents: []
                };
            }
            const range = {
                start: protocol_translation_2.toPosition(result.body.start),
                end: protocol_translation_2.toPosition(result.body.end)
            };
            const contents = [
                { language: 'typescript', value: result.body.displayString }
            ];
            if (result.body.documentation) {
                contents.push(result.body.documentation);
            }
            return {
                contents,
                range
            };
        });
    }
    rename(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('onRename', params, path);
            const result = yield this.tspClient.request("rename" /* Rename */, {
                file: path,
                line: params.position.line + 1,
                offset: params.position.character + 1
            });
            const workspaceEdit = {
                changes: {}
            };
            if (!result.body || !result.body.info.canRename || result.body.locs.length === 0) {
                return workspaceEdit;
            }
            result.body.locs
                .forEach((spanGroup) => {
                const uri = protocol_translation_2.pathToUri(spanGroup.file), textEdits = workspaceEdit.changes[uri] || (workspaceEdit.changes[uri] = []);
                spanGroup.locs.forEach((textSpan) => {
                    textEdits.push({
                        newText: params.newName,
                        range: {
                            start: protocol_translation_2.toPosition(textSpan.start),
                            end: protocol_translation_2.toPosition(textSpan.end)
                        }
                    });
                });
            });
            return workspaceEdit;
        });
    }
    references(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('onReferences', params, path);
            const result = yield this.tspClient.request("references" /* References */, {
                file: path,
                line: params.position.line + 1,
                offset: params.position.character + 1
            });
            if (!result.body) {
                return [];
            }
            return result.body.refs
                .map(fileSpan => protocol_translation_2.toLocation(fileSpan));
        });
    }
    documentFormatting(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('documentFormatting', params, path);
            let opts = Object.assign({}, params.options);
            // translate
            if (!opts.convertTabsToSpaces) {
                opts.convertTabsToSpaces = params.options.insertSpaces;
            }
            try {
                opts = JSON.parse(fs.readFileSync(this.rootPath() + "/tsfmt.json", 'utf-8'));
            }
            catch (err) {
                this.logger.log("No formatting options found " + err);
            }
            // options are not yet supported in tsserver, but we can send a configure request first
            this.tspClient.request("configure" /* Configure */, {
                formatOptions: opts
            });
            const response = yield this.tspClient.request("format" /* Format */, {
                file: path,
                line: 1,
                offset: 1,
                endLine: Number.MAX_SAFE_INTEGER,
                endOffset: Number.MAX_SAFE_INTEGER,
                options: opts
            });
            if (response.body) {
                return response.body.map(e => protocol_translation_2.toTextEdit(e));
            }
            return [];
        });
    }
    signatureHelp(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = protocol_translation_2.uriToPath(params.textDocument.uri);
            this.logger.log('signatureHelp', params, path);
            const response = yield this.tspClient.request("signatureHelp" /* SignatureHelp */, {
                file: path,
                line: params.position.line + 1,
                offset: params.position.character + 1
            });
            if (!response.body) {
                return {
                    signatures: [],
                    activeSignature: null,
                    activeParameter: null
                };
            }
            const info = response.body;
            const signatures = [];
            let activeSignature = response.body.selectedItemIndex;
            let activeParameter = response.body.argumentIndex;
            response.body.items.forEach((item, i) => {
                // keep active parameter in bounds
                if (i === info.selectedItemIndex && item.isVariadic) {
                    activeParameter = Math.min(info.argumentIndex, item.parameters.length - 1);
                }
                let label = protocol_translation_2.toPlainText(item.prefixDisplayParts);
                const parameters = [];
                item.parameters.forEach((p, i, a) => {
                    const parameter = lsp.ParameterInformation.create(protocol_translation_2.toPlainText(p.displayParts), protocol_translation_2.toPlainText(p.documentation));
                    label += parameter.label;
                    parameters.push(parameter);
                    if (i < a.length - 1) {
                        label += protocol_translation_2.toPlainText(item.separatorDisplayParts);
                    }
                });
                label += protocol_translation_2.toPlainText(item.suffixDisplayParts);
                const documentation = protocol_translation_2.toMarkDown(item.documentation, item.tags);
                signatures.push({
                    label,
                    documentation,
                    parameters
                });
            });
            return {
                signatures,
                activeSignature,
                activeParameter
            };
        });
    }
    codeAction(arg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log('codeAction', arg);
            let response;
            try {
                response = yield this.tspClient.request("getCodeFixes" /* GetCodeFixes */, {
                    file: protocol_translation_2.uriToPath(arg.textDocument.uri),
                    startLine: arg.range.start.line + 1,
                    startOffset: arg.range.start.character + 1,
                    endLine: arg.range.end.line + 1,
                    endOffset: arg.range.end.character + 1,
                    errorCodes: arg.context.diagnostics.map(d => d.code)
                });
            }
            catch (err) {
                return [];
            }
            if (!response.body) {
                return [];
            }
            const result = [];
            for (const fix of response.body) {
                result.push({
                    title: fix.description,
                    command: exports.WORKSPACE_EDIT_COMMAND,
                    arguments: [{
                            documentChanges: fix.changes.map(c => protocol_translation_2.toTextDocumentEdit(c))
                        }]
                });
            }
            return result;
        });
    }
    executeCommand(arg) {
        this.logger.log('executeCommand', arg);
        if (arg.command === exports.WORKSPACE_EDIT_COMMAND && arg.arguments) {
            const edit = arg.arguments[0];
            this.options.lspClient.applyWorkspaceEdit({
                edit
            });
        }
        else {
            this.logger.error(`Unknown command ${arg.command}.`);
        }
    }
    documentHighlight(arg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log('documentHighlight', arg);
            let response;
            const file = protocol_translation_2.uriToPath(arg.textDocument.uri);
            try {
                response = yield this.tspClient.request("documentHighlights" /* DocumentHighlights */, {
                    file: file,
                    line: arg.position.line + 1,
                    offset: arg.position.character + 1,
                    filesToSearch: [file]
                });
            }
            catch (err) {
                return [];
            }
            if (!response.body) {
                return [];
            }
            const result = [];
            for (const item of response.body) {
                if (item.file === file) {
                    const highlights = protocol_translation_1.toDocumentHighlight(item);
                    result.push(...highlights);
                }
            }
            return result;
        });
    }
    rootPath() {
        return this.initializeParams.rootUri ? protocol_translation_2.uriToPath(this.initializeParams.rootUri) : this.initializeParams.rootPath;
    }
    lastFileOrDummy() {
        for (const uri of this.openedDocumentUris.keys()) {
            return protocol_translation_2.uriToPath(uri);
        }
        return this.rootPath();
    }
    workspaceSymbol(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.tspClient.request("navto" /* Navto */, {
                file: this.lastFileOrDummy(),
                searchValue: params.query
            });
            if (!result.body) {
                return [];
            }
            return result.body.map(item => {
                return {
                    location: {
                        uri: protocol_translation_2.pathToUri(item.file),
                        range: {
                            start: protocol_translation_2.toPosition(item.start),
                            end: protocol_translation_2.toPosition(item.end)
                        }
                    },
                    kind: protocol_translation_2.toSymbolKind(item.kind),
                    name: item.name
                };
            });
        });
    }
    onTsEvent(event) {
        if (event.event === "semanticDiag" /* SementicDiag */) {
            this.diagnosticQueue.addSemanticDiagnostic(event);
        }
        else if (event.event === "syntaxDiag" /* SyntaxDiag */) {
            this.diagnosticQueue.addSyntacticDiagnostic(event);
        }
        else {
            this.logger.log("Ignored event : " + event.type, event);
        }
    }
}
exports.LspServer = LspServer;
//# sourceMappingURL=lsp-server.js.map