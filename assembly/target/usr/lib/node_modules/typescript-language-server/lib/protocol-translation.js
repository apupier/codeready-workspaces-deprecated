"use strict";
/*
 * Copyright (C) 2017, 2018 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const lsp = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const utils_1 = require("./utils");
function uriToPath(stringUri) {
    const uri = vscode_uri_1.default.parse(stringUri);
    if (uri.scheme !== 'file') {
        throw new Error(`The Typescript Language Server only supports file-scheme URIs. Received "${stringUri}"`);
    }
    return uri.fsPath;
}
exports.uriToPath = uriToPath;
function pathToUri(p) {
    return 'file://' + (utils_1.isWindows() ? '/' + p.replace(/\//g, '/') : p);
}
exports.pathToUri = pathToUri;
function toPosition(location) {
    return {
        line: location.line - 1,
        character: location.offset - 1
    };
}
exports.toPosition = toPosition;
function toLocation(fileSpan) {
    return {
        uri: pathToUri(fileSpan.file),
        range: {
            start: toPosition(fileSpan.start),
            end: toPosition(fileSpan.end)
        }
    };
}
exports.toLocation = toLocation;
exports.completionKindsMapping = {
    class: lsp.CompletionItemKind.Class,
    constructor: lsp.CompletionItemKind.Constructor,
    enum: lsp.CompletionItemKind.Enum,
    field: lsp.CompletionItemKind.Field,
    file: lsp.CompletionItemKind.File,
    function: lsp.CompletionItemKind.Function,
    interface: lsp.CompletionItemKind.Interface,
    keyword: lsp.CompletionItemKind.Keyword,
    method: lsp.CompletionItemKind.Method,
    module: lsp.CompletionItemKind.Module,
    property: lsp.CompletionItemKind.Property,
    reference: lsp.CompletionItemKind.Reference,
    snippet: lsp.CompletionItemKind.Snippet,
    text: lsp.CompletionItemKind.Text,
    unit: lsp.CompletionItemKind.Unit,
    value: lsp.CompletionItemKind.Value,
    variable: lsp.CompletionItemKind.Variable
};
const symbolKindsMapping = {
    'enum member': lsp.SymbolKind.Constant,
    'JSX attribute': lsp.SymbolKind.Property,
    'local class': lsp.SymbolKind.Class,
    'local function': lsp.SymbolKind.Function,
    'local var': lsp.SymbolKind.Variable,
    'type parameter': lsp.SymbolKind.Variable,
    alias: lsp.SymbolKind.Variable,
    class: lsp.SymbolKind.Class,
    const: lsp.SymbolKind.Constant,
    constructor: lsp.SymbolKind.Constructor,
    enum: lsp.SymbolKind.Enum,
    field: lsp.SymbolKind.Field,
    file: lsp.SymbolKind.File,
    function: lsp.SymbolKind.Function,
    getter: lsp.SymbolKind.Method,
    interface: lsp.SymbolKind.Interface,
    let: lsp.SymbolKind.Variable,
    method: lsp.SymbolKind.Method,
    module: lsp.SymbolKind.Module,
    parameter: lsp.SymbolKind.Variable,
    property: lsp.SymbolKind.Property,
    setter: lsp.SymbolKind.Method,
    var: lsp.SymbolKind.Variable
};
function toSymbolKind(tspKind) {
    return symbolKindsMapping[tspKind] || lsp.SymbolKind.Variable;
}
exports.toSymbolKind = toSymbolKind;
function toDiagnosticSeverity(category) {
    switch (category) {
        case 'error': return lsp.DiagnosticSeverity.Error;
        case 'warning': return lsp.DiagnosticSeverity.Warning;
        default: return lsp.DiagnosticSeverity.Information;
    }
}
exports.toDiagnosticSeverity = toDiagnosticSeverity;
function toDiagnostic(tspDiag) {
    return {
        range: {
            start: toPosition(tspDiag.start),
            end: toPosition(tspDiag.end)
        },
        message: tspDiag.text,
        severity: toDiagnosticSeverity(tspDiag.category),
        code: tspDiag.code,
        source: 'typescript'
    };
}
exports.toDiagnostic = toDiagnostic;
function toTextEdit(edit) {
    return {
        range: {
            start: toPosition(edit.start),
            end: toPosition(edit.end)
        },
        newText: edit.newText
    };
}
exports.toTextEdit = toTextEdit;
function toPlainText(parts) {
    return parts.map(part => part.text).join('');
}
exports.toPlainText = toPlainText;
function tagsMarkdownPreview(tags) {
    return (tags || [])
        .map(tag => {
        const label = `*@${tag.name}*`;
        if (!tag.text) {
            return label;
        }
        return label + (tag.text.match(/\r\n|\n/g) ? '  \n' + tag.text : ` â€” ${tag.text}`);
    })
        .join('  \n\n');
}
function toMarkDown(documentation, tags) {
    let result = "";
    result += toPlainText(documentation);
    const tagsPreview = tagsMarkdownPreview(tags);
    if (tagsPreview) {
        result += '\n\n' + tagsPreview;
    }
    return result;
}
exports.toMarkDown = toMarkDown;
function toTextDocumentEdit(change) {
    return {
        textDocument: {
            uri: pathToUri(change.fileName),
            version: 0 // TODO
        },
        edits: change.textChanges.map(c => toTextEdit(c))
    };
}
exports.toTextDocumentEdit = toTextDocumentEdit;
function toDocumentHighlight(item) {
    return item.highlightSpans.map(i => {
        return {
            kind: toDocumentHighlightKind(i.kind),
            range: {
                start: toPosition(i.start),
                end: toPosition(i.end)
            }
        };
    });
}
exports.toDocumentHighlight = toDocumentHighlight;
// copied because the protocol module is not available at runtime (js version).
var HighlightSpanKind;
(function (HighlightSpanKind) {
    HighlightSpanKind["none"] = "none";
    HighlightSpanKind["definition"] = "definition";
    HighlightSpanKind["reference"] = "reference";
    HighlightSpanKind["writtenReference"] = "writtenReference";
})(HighlightSpanKind || (HighlightSpanKind = {}));
function toDocumentHighlightKind(kind) {
    switch (kind) {
        case HighlightSpanKind.definition: return lsp.DocumentHighlightKind.Write;
        case HighlightSpanKind.reference:
        case HighlightSpanKind.writtenReference: return lsp.DocumentHighlightKind.Read;
        default: return lsp.DocumentHighlightKind.Text;
    }
}
//# sourceMappingURL=protocol-translation.js.map