"use strict";
/*
 * Copyright (C) 2017, 2018 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
const lsp = require("vscode-languageserver");
const test_utils_1 = require("./test-utils");
const document_1 = require("./document");
const assert = chai.assert;
const expect = chai.expect;
let diagnostics;
let server;
before(() => __awaiter(this, void 0, void 0, function* () {
    server = yield test_utils_1.createServer({
        rootUri: '',
        publishDiagnostics: args => diagnostics = args
    });
}));
beforeEach(() => {
    server.closeAll();
});
describe('completion', () => {
    it('simple test', () => __awaiter(this, void 0, void 0, function* () {
        const doc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        export function foo(): void {
          console.log('test')
        }
      `
        };
        server.didOpenTextDocument({
            textDocument: doc
        });
        const pos = test_utils_1.position(doc, 'console');
        const proposals = yield server.completion({
            textDocument: doc,
            position: pos
        });
        assert.isTrue(proposals.items.length > 800);
        const item = proposals.items.filter(i => i.label === 'addEventListener')[0];
        const resolvedItem = yield server.completionResolve(item);
        assert.isTrue(resolvedItem.documentation !== undefined);
        server.didCloseTextDocument({
            textDocument: doc
        });
    })).timeout(10000);
});
describe('diagnostics', () => {
    it('simple test', () => __awaiter(this, void 0, void 0, function* () {
        const doc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        export function foo(): void {
          unknown('test')
        }
      `
        };
        server.didOpenTextDocument({
            textDocument: doc
        });
        yield server.requestDiagnostics();
        yield server.requestDiagnostics();
        const diags = diagnostics.diagnostics;
        assert.equal(1, diags.length);
        assert.equal("Cannot find name 'unknown'.", diags[0].message);
    })).timeout(10000);
});
describe('symbol', () => {
    it('simple test', () => __awaiter(this, void 0, void 0, function* () {
        const doc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        export class Foo {
          protected foo: string;
          public myFunction(arg: string) {
          }
        }
      `
        };
        server.didOpenTextDocument({
            textDocument: doc
        });
        const symbols = yield server.documentSymbol({
            textDocument: doc,
            position: lsp.Position.create(1, 1)
        });
        assert.equal(4, symbols.length);
        assert.equal('"bar"', symbols[0].name);
        assert.equal('Foo', symbols[1].name);
        assert.equal('foo', symbols[2].name);
        assert.equal('myFunction', symbols[3].name);
    })).timeout(10000);
});
describe('editing', () => {
    it('open and change', () => __awaiter(this, void 0, void 0, function* () {
        const doc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        export function foo(): void {
        }
      `
        };
        server.didOpenTextDocument({
            textDocument: doc
        });
        server.didChangeTextDocument({
            textDocument: doc,
            contentChanges: [
                {
                    text: `
          export function foo(): void {
            unknown('test');
          }
          `
                }
            ]
        });
        yield server.requestDiagnostics();
        yield server.requestDiagnostics();
        const diags = diagnostics.diagnostics;
        assert.isTrue(diags.length >= 1, diags.map(d => d.message).join(','));
        assert.equal("Cannot find name 'unknown'.", diags[0].message);
    })).timeout(10000);
});
describe('formatting', () => {
    it('full document formatting', () => __awaiter(this, void 0, void 0, function* () {
        const doc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: 'export  function foo (     )   :  void   {   }'
        };
        server.didOpenTextDocument({
            textDocument: doc
        });
        const edits = yield server.documentFormatting({
            textDocument: doc,
            options: {
                tabSize: 4,
                insertSpaces: true
            }
        });
        const result = document_1.applyEdits(doc.text, edits);
        assert.equal('export function foo(): void { }', result);
    })).timeout(10000);
});
describe('signatureHelp', () => {
    it('simple test', () => __awaiter(this, void 0, void 0, function* () {
        const doc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        export function foo(bar: string, baz?:boolean): void {}
        foo(param1, param2)
      `
        };
        server.didOpenTextDocument({
            textDocument: doc
        });
        let result = yield server.signatureHelp({
            textDocument: doc,
            position: test_utils_1.position(doc, 'param1')
        });
        assert.equal('bar: string', result.signatures[result.activeSignature].parameters[result.activeParameter].label);
        result = yield server.signatureHelp({
            textDocument: doc,
            position: test_utils_1.position(doc, 'param2')
        });
        assert.equal('baz?: boolean', result.signatures[result.activeSignature].parameters[result.activeParameter].label);
    })).timeout(10000);
});
describe('documentHighlight', () => {
    it('simple test', () => __awaiter(this, void 0, void 0, function* () {
        const barDoc = {
            uri: test_utils_1.uri('bar.d.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        export declare const Bar: unique symbol;
        export interface Bar {
        }
      `
        };
        server.didOpenTextDocument({
            textDocument: barDoc
        });
        const fooDoc = {
            uri: test_utils_1.uri('bar.ts'),
            languageId: 'typescript',
            version: 1,
            text: `
        import { Bar } from './bar';
        export class Foo implements Bar {
        }
      `
        };
        server.didOpenTextDocument({
            textDocument: fooDoc
        });
        const result = yield server.documentHighlight({
            textDocument: fooDoc,
            position: test_utils_1.lastPosition(fooDoc, 'Bar')
        });
        assert.equal(2, result.length, JSON.stringify(result, undefined, 2));
    })).timeout(10000);
});
//# sourceMappingURL=lsp-server.spec.js.map