"use strict";
/*
 * Copyright (C) 2017, 2018 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const protocol_translation_1 = require("./protocol-translation");
class DiagnosticEventQueue {
    constructor(publicDiagnostics, logger) {
        this.publicDiagnostics = publicDiagnostics;
        this.logger = logger;
        this.pendingSyntaxDiagnostics = new Map();
    }
    addSyntacticDiagnostic(event) {
        if (!event.body) {
            this.logger.error("Received empty syntactic diagnostics.");
            return;
        }
        this.pendingSyntaxDiagnostics.set(this.key(event), event);
    }
    key(event) {
        return event.seq + event.body.file;
    }
    addSemanticDiagnostic(event) {
        const syntax = this.pendingSyntaxDiagnostics.get(this.key(event));
        if (!event.body) {
            this.logger.error("Received empty semantic diagnostics.");
            return;
        }
        if (!syntax) {
            this.logger.error("Received semantic diagnostics without previsou syntactic ones, for file : " + event.body.file);
            return;
        }
        this.pendingSyntaxDiagnostics.delete(this.key(event));
        const diagnostics = [];
        for (const d of syntax.body.diagnostics) {
            diagnostics.push(protocol_translation_1.toDiagnostic(d));
        }
        for (const d of event.body.diagnostics) {
            diagnostics.push(protocol_translation_1.toDiagnostic(d));
        }
        const result = {
            uri: protocol_translation_1.pathToUri(event.body.file),
            diagnostics
        };
        this.publicDiagnostics(result);
    }
}
exports.DiagnosticEventQueue = DiagnosticEventQueue;
//# sourceMappingURL=diagnostic-queue.js.map